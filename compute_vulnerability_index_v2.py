#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Compute Vulnerability Index v2 (agricultural vulnerability) â€“ versiunea cu CAMS PM2.5 ANNUAL

Workflow:
- CiteÈ™te ground_truth_with_predictions_pm25annual.csv (care are CAMS_PM25_annual)
- ImputeazÄƒ lipsurile cu KNNImputer (inclusiv PM2.5 anual)
- NormalizeazÄƒ indicatorii de risc
- CalculeazÄƒ un Vulnerability Index v2 Ã®n [0, 1]
- RuleazÄƒ KMeans(K=4) pentru a obÈ›ine 4 clustere ordonate (0 = low, 3 = very high)
- SalveazÄƒ rezultatele Ã®ntr-un nou CSV:
    ground_truth_with_predictions_v2_pm25annual.csv
"""

from pathlib import Path

import numpy as np
import pandas as pd
from sklearn.cluster import KMeans
from sklearn.impute import KNNImputer
from sklearn.preprocessing import MinMaxScaler

# ---------------------------------------------------------
# Paths
# ---------------------------------------------------------
BASE_DIR = Path("/content/drive/MyDrive/AgriVulnAI")
CSV_IN = BASE_DIR / "data" / "processed" / "ground_truth_with_predictions_pm25annual.csv"
CSV_OUT = BASE_DIR / "data" / "processed" / "ground_truth_with_predictions_v2_pm25annual.csv"

print(BASE_DIR)
print(f"ðŸ“‚ Input:  {CSV_IN}")
print(f"ðŸ“‚ Output: {CSV_OUT}")

# ---------------------------------------------------------
# Load data
# ---------------------------------------------------------
df = pd.read_csv(CSV_IN)
print(f"Loaded {len(df)} rows.")
print("Columns:", list(df.columns))

# ---------------------------------------------------------
# Select features for vulnerability index
# ---------------------------------------------------------
# Folosim indicatorii cei mai relevanÈ›i:
# - NDVI_2023-03-01 (vegetation greenness â€“ low = stressed)
# - EVI_2023-03-01  (complementary vegetation index)
# - CHIRPS_precip_2023-03-01 (rainfall â€“ low = drought risk)
# - PM25_2023-03-01 (local PM2.5, daily/3-month product)
# - CAMS_PM25_annual (annual PM2.5 background, from GEE)
# - Water_occurrence (hydro context; low water = more risk)
# - WorldPop_2020 (population density = exposure)
#
# NOTÄ‚: pred_class Ã®l folosim la model, dar aici pÄƒstrÄƒm indexul v2
# bazat pe indicatori fizici / socio-economici, nu pe label.
feature_cols = [
    "NDVI_2023-03-01",
    "EVI_2023-03-01",
    "CHIRPS_precip_2023-03-01",
    "PM25_2023-03-01",
    "CAMS_PM25_annual",
    "Water_occurrence",
    "WorldPop_2020",
]

# VerificÄƒm ce coloane chiar existÄƒ
available = [c for c in feature_cols if c in df.columns]
missing = [c for c in feature_cols if c not in df.columns]

print("\nâœ… Feature columns available:")
for c in available:
    print(f"  - {c}")

if missing:
    print("\nâš ï¸ Missing feature columns (vor fi ignorate):")
    for c in missing:
        print(f"  - {c}")

feature_cols = available  # doar cele care existÄƒ
X = df[feature_cols].copy()

print("\nðŸ“Š Missing values BEFORE KNN imputer:")
print(X.isna().sum())

# ---------------------------------------------------------
# KNN Imputation (stabilizeazÄƒ lipsurile)
# ---------------------------------------------------------
imputer = KNNImputer(n_neighbors=6, weights="uniform")
X_imputed = imputer.fit_transform(X)
X_imputed = pd.DataFrame(X_imputed, columns=feature_cols)

print("\nðŸ“Š Missing values AFTER KNN imputer (ar trebui sÄƒ fie 0):")
print(X_imputed.isna().sum())

# ---------------------------------------------------------
# Build risk components & Vulnerability Index v2
# ---------------------------------------------------------
# Ideea:
# - Vegetation risk: 1 - scaled(NDVI)  (low NDVI = high risk)
# - Rainfall risk: 1 - scaled(CHIRPS) (low rain = high risk)
# - Local PM2.5 risk: scaled(PM25_2023-03-01)
# - Annual PM2.5 risk: scaled(CAMS_PM25_annual)
# - Water risk: 1 - scaled(Water_occurrence) (low water = high risk)
# - Population risk: scaled(WorldPop_2020) (densitate mare = expunere mare)

scaler = MinMaxScaler(feature_range=(0, 1))

components = []

# 1) Vegetation (NDVI)
if "NDVI_2023-03-01" in feature_cols:
    ndvi_scaled = scaler.fit_transform(X_imputed[["NDVI_2023-03-01"]])
    veg_risk = 1.0 - ndvi_scaled  # low NDVI -> high risk
    components.append(veg_risk)
else:
    veg_risk = None

# 2) Rainfall (CHIRPS)
if "CHIRPS_precip_2023-03-01" in feature_cols:
    rain_scaled = scaler.fit_transform(X_imputed[["CHIRPS_precip_2023-03-01"]])
    rain_risk = 1.0 - rain_scaled  # low rain -> high risk
    components.append(rain_risk)
else:
    rain_risk = None

# 3) Local PM2.5
if "PM25_2023-03-01" in feature_cols:
    pm25_scaled = scaler.fit_transform(X_imputed[["PM25_2023-03-01"]])
    pm25_risk = pm25_scaled  # high PM2.5 -> high risk
    components.append(pm25_risk)
else:
    pm25_risk = None

# 4) CAMS annual PM2.5
if "CAMS_PM25_annual" in feature_cols:
    cams_scaled = scaler.fit_transform(X_imputed[["CAMS_PM25_annual"]])
    cams_risk = cams_scaled  # high annual PM2.5 -> high risk
    components.append(cams_risk)
else:
    cams_risk = None

# 5) Water occurrence
if "Water_occurrence" in feature_cols:
    water_scaled = scaler.fit_transform(X_imputed[["Water_occurrence"]])
    water_risk = 1.0 - water_scaled  # low water occurrence -> higher risk
    components.append(water_risk)
else:
    water_risk = None

# 6) Population density
if "WorldPop_2020" in feature_cols:
    pop_scaled = scaler.fit_transform(X_imputed[["WorldPop_2020"]])
    pop_risk = pop_scaled  # high population -> high exposure
    components.append(pop_risk)
else:
    pop_risk = None

if not components:
    raise RuntimeError("Nu avem niciun component de risc pentru index!")

# Stack all risk components & compute mean risk
risk_matrix = np.hstack(components)  # shape: (n_samples, n_components)
vuln_raw = risk_matrix.mean(axis=1)  # average across components

scaler_idx = MinMaxScaler(feature_range=(0, 1))
vuln_index_v2 = scaler_idx.fit_transform(vuln_raw.reshape(-1, 1)).ravel()

df["vuln_index_v2"] = vuln_index_v2

print("\nðŸ“ˆ Vulnerability Index v2 stats (0â€“1):")
print(df["vuln_index_v2"].describe())

# ---------------------------------------------------------
# KMeans clustering Ã®n 4 niveluri de risc (low â†’ very high)
# ---------------------------------------------------------
print("\nðŸ¤– Running KMeans with K=4 on risk index...")

kmeans = KMeans(n_clusters=4, random_state=42, n_init=10)
clusters_raw = kmeans.fit_predict(vuln_index_v2.reshape(-1, 1))

# ReordonÄƒm clusterele dupÄƒ media indexului (0 = lowest risk, 3 = highest risk)
cluster_means = {}
for c in range(4):
    cluster_means[c] = vuln_index_v2[clusters_raw == c].mean()

sorted_clusters = sorted(cluster_means.items(), key=lambda x: x[1])
mapping = {old: new for new, (old, _) in enumerate(sorted_clusters)}

clusters_ordered = np.vectorize(mapping.get)(clusters_raw)
df["vuln_cluster_v2"] = clusters_ordered

print("\nðŸ“Š Cluster means (ordonate lowâ†’high):")
for c in range(4):
    mean_val = df.loc[df["vuln_cluster_v2"] == c, "vuln_index_v2"].mean()
    count = int((df["vuln_cluster_v2"] == c).sum())
    print(f"  Cluster {c}: mean index={mean_val:.3f}, n={count}")

# ---------------------------------------------------------
# Save final CSV
# ---------------------------------------------------------
df.to_csv(CSV_OUT, index=False)
print("\nâœ… Saved with v2 index & clusters (annual PM2.5) to:")
print(f"   {CSV_OUT}")
print("Columns now include: 'vuln_index_v2', 'vuln_cluster_v2'")
